//! Exploratory workflow strategy.
//!
//! Implements an exploratory approach by composing Tree of Thoughts pattern
//! to explore multiple solution paths and select the best approach.
//!
//! This strategy is ideal for:
//! - Open-ended questions with multiple valid approaches
//! - Creative problem solving
//! - Tasks requiring lateral thinking
//! - Exploring trade-offs between different solutions
//!
//! # Example
//!
//! ```rust,ignore
//! let renderer = PromptRenderer::new()?;
//! let workflow = ExploratoryWorkflow::new(renderer);
//! let result = workflow.execute(&task).await?;
//! ```

use super::Strategy;
use crate::workflow::prompts::PromptRenderer;
use crate::workflow::task::Task;
use anyhow::{Context, Result};
use async_trait::async_trait;
use serde_json::json;

/// Exploratory workflow strategy.
///
/// Uses Tree of Thoughts to explore multiple solution paths simultaneously,
/// evaluating each branch and selecting the most promising approach.
///
/// # Architecture
///
/// 1. **Branch Generation (ToT)**: Creates multiple solution paths exploring
///    different approaches to the problem
/// 2. **Path Evaluation**: Scores each branch based on feasibility, quality,
///    and alignment with requirements
/// 3. **Best Path Selection**: Selects and expands the highest-scoring path
/// 4. **Synthesis**: Combines insights from all explored paths
///
/// # Token Budget
///
/// This strategy explores multiple paths in parallel, consuming 2-4x tokens
/// compared to linear execution. Number of branches can be configured.
#[derive(Debug)]
pub struct ExploratoryWorkflow {
    /// Prompt renderer for templating.
    renderer: PromptRenderer,
    /// Number of solution branches to explore.
    branches: usize,
}

impl ExploratoryWorkflow {
    /// Create a new exploratory workflow strategy.
    ///
    /// # Arguments
    ///
    /// * `renderer` - Prompt renderer for generating pattern prompts
    #[must_use]
    pub fn new(renderer: PromptRenderer) -> Self {
        Self {
            renderer,
            branches: 3,
        }
    }

    /// Create with custom number of branches.
    ///
    /// # Arguments
    ///
    /// * `renderer` - Prompt renderer for generating pattern prompts
    /// * `branches` - Number of solution paths to explore (typically 2-5)
    #[must_use]
    pub fn with_branches(mut self, branches: usize) -> Self {
        self.branches = branches.max(1).min(10); // Clamp to reasonable range
        self
    }

    /// Extract context as string from task.
    fn extract_context(task: &Task) -> String {
        if let Some(ctx_array) = task.context.as_array() {
            ctx_array
                .iter()
                .filter_map(|v| v.as_str())
                .collect::<Vec<_>>()
                .join("\n")
        } else if let Some(ctx_str) = task.context.as_str() {
            ctx_str.to_string()
        } else {
            String::new()
        }
    }
}

#[async_trait]
impl Strategy for ExploratoryWorkflow {
    async fn execute(&self, task: &Task) -> Result<String> {
        tracing::info!(
            task_id = %task.id,
            strategy = "exploratory",
            branches = self.branches,
            "ðŸŒ³ Starting exploratory workflow execution"
        );

        // Stage 1: Tree of Thoughts (Branch Generation & Evaluation)
        tracing::debug!(
            task_id = %task.id,
            stage = "tree_of_thoughts",
            branches = self.branches,
            "Generating solution branches"
        );

        let tot_context = json!({
            "query": task.query,
            "context": Self::extract_context(task),
            "branches": self.branches.to_string(),
        });

        let tot_prompts = self
            .renderer
            .render("tree_of_thoughts", &tot_context)
            .context("Failed to render tree_of_thoughts prompt")?;

        // TODO: Replace with actual LLM call via pattern registry
        // For now, simulate branch exploration
        let mut branch_results = Vec::new();
        for i in 1..=self.branches {
            let branch = format!(
                "**Branch {}**\n\
                 Approach: [Branch {} approach description]\n\
                 Feasibility: {}/10\n\
                 Expected outcome: [Expected results]\n\
                 Pros: [Advantages of this approach]\n\
                 Cons: [Disadvantages of this approach]",
                i,
                i,
                7 + (i % 3) // Simulate varying scores
            );
            branch_results.push(branch);
        }

        let tot_output = format!(
            "**Solution Space Exploration (Tree of Thoughts)**\n\n\
             Explored {} solution branches:\n\n{}\n\n\
             [This is a placeholder. In production, this would be generated by \
             calling an LLM with the rendered ToT prompt]\n\n\
             Prompt tokens: {}, estimated tokens: {}",
            self.branches,
            branch_results.join("\n\n"),
            tot_prompts.metadata.pattern,
            tot_prompts.metadata.estimated_tokens
        );

        tracing::debug!(
            task_id = %task.id,
            stage = "tree_of_thoughts",
            branches = self.branches,
            tokens = tot_prompts.metadata.estimated_tokens,
            "âœ… Solution branches explored"
        );

        // Stage 2: Best Path Selection & Synthesis
        tracing::debug!(
            task_id = %task.id,
            stage = "synthesis",
            "Synthesizing insights from all branches"
        );

        let synthesis = format!(
            "**Synthesis**\n\n\
             After exploring {} solution paths, the recommended approach is:\n\n\
             **Selected Path**: Branch 1 (highest feasibility score)\n\n\
             **Rationale**: This approach balances feasibility, impact, and resource requirements.\n\n\
             **Implementation Steps**:\n\
             1. [Step 1 from selected branch]\n\
             2. [Step 2 from selected branch]\n\
             3. [Step 3 from selected branch]\n\n\
             **Alternative Considerations**: Insights from other branches that could enhance the solution:\n\
             - [Insight from Branch 2]\n\
             - [Insight from Branch 3]",
            self.branches
        );

        tracing::debug!(
            task_id = %task.id,
            stage = "synthesis",
            "âœ… Synthesis completed"
        );

        // Build final result
        let final_result = format!(
            "# Exploratory Analysis\n\n\
             Query: {}\n\n\
             ## Phase 1: Solution Space Exploration\n{}\n\n\
             ## Phase 2: Best Path Selection\n{}\n\n\
             ---\n\
             **Workflow Statistics**\n\
             - Solution branches explored: {}\n\
             - Total estimated tokens: {}\n\
             - Stages completed: 2/2\n\
             - Strategy: Exploratory (Tree of Thoughts)",
            task.query,
            tot_output,
            synthesis,
            self.branches,
            tot_prompts.metadata.estimated_tokens
        );

        tracing::info!(
            task_id = %task.id,
            strategy = "exploratory",
            branches = self.branches,
            total_tokens = tot_prompts.metadata.estimated_tokens,
            "ðŸŽ‰ Exploratory workflow execution completed"
        );

        Ok(final_result)
    }

    fn name(&self) -> &str {
        "Exploratory"
    }

    fn description(&self) -> &str {
        "Exploratory workflow using Tree of Thoughts to explore multiple \
         solution paths and synthesize the best approach"
    }

    fn patterns(&self) -> Vec<&str> {
        vec!["tree_of_thoughts"]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::workflow::task::Strategy as TaskStrategy;

    #[tokio::test]
    async fn test_exploratory_workflow_execute() {
        let renderer = PromptRenderer::new().unwrap();
        let workflow = ExploratoryWorkflow::new(renderer);

        let task = Task::new(
            "task-1",
            "user-1",
            "What are the best approaches to reduce technical debt?",
        )
        .with_strategy(TaskStrategy::TreeOfThoughts);

        let result = workflow.execute(&task).await.unwrap();

        // Verify key sections are present
        assert!(result.contains("Solution Space Exploration"));
        assert!(result.contains("Best Path Selection"));
        assert!(result.contains("Branch 1"));
        assert!(result.contains("Branch 2"));
        assert!(result.contains("Branch 3"));
        assert!(result.contains("Exploratory Analysis"));
    }

    #[tokio::test]
    async fn test_exploratory_workflow_custom_branches() {
        let renderer = PromptRenderer::new().unwrap();
        let workflow = ExploratoryWorkflow::new(renderer).with_branches(5);

        let task = Task::new("task-1", "user-1", "test query");
        let result = workflow.execute(&task).await.unwrap();

        assert!(result.contains("Explored 5 solution branches"));
    }

    #[tokio::test]
    async fn test_exploratory_workflow_branch_clamping() {
        let renderer = PromptRenderer::new().unwrap();

        // Test minimum clamping
        let workflow_min = ExploratoryWorkflow::new(renderer.clone()).with_branches(0);
        let task = Task::new("task-1", "user-1", "test");
        let result = workflow_min.execute(&task).await.unwrap();
        assert!(result.contains("Explored 1 solution branches"));

        // Test maximum clamping
        let workflow_max = ExploratoryWorkflow::new(renderer).with_branches(20);
        let task = Task::new("task-2", "user-1", "test");
        let result = workflow_max.execute(&task).await.unwrap();
        assert!(result.contains("Explored 10 solution branches"));
    }

    #[tokio::test]
    async fn test_exploratory_workflow_metadata() {
        let renderer = PromptRenderer::new().unwrap();
        let workflow = ExploratoryWorkflow::new(renderer);

        assert_eq!(workflow.name(), "Exploratory");
        assert_eq!(workflow.patterns().len(), 1);
        assert!(workflow.description().contains("Tree of Thoughts"));
    }

    #[tokio::test]
    async fn test_extract_context() {
        let task = Task::new("task-1", "user-1", "test")
            .with_context(json!(["context1", "context2"]));

        let context = ExploratoryWorkflow::extract_context(&task);
        assert_eq!(context, "context1\ncontext2");
    }
}
